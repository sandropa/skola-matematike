# server/schemas/problem.py
from pydantic import BaseModel, ConfigDict, Field # <-- Added Field
from typing import Optional, List, Literal # <-- Added Literal

# Define the allowed categories
CategoryLiteral = Literal['A', 'N', 'G', 'C']

# Base schema with common fields (used for input and inheritance)
class ProblemBase(BaseModel):
    latex_text: str
    # Use Literal for category validation at the schema level
    category: CategoryLiteral = Field(..., examples=['A', 'N', 'G', 'C'])
    comments: Optional[str] = None
    # Use JSON compatible type hint if storing complex JSON, keep List[str] if simple list
    latex_versions: Optional[List[str]] = None # Or Optional[Any] if complex JSON
    solution: Optional[str] = None

# Schema for creating a new problem (used in POST request body)
class ProblemCreate(ProblemBase):
    pass # Inherits all fields from ProblemBase

# Schema for updating a problem via PUT (requires all fields)
class ProblemUpdate(ProblemBase):
    pass

# --- NEW SCHEMA FOR PATCH ---
# Schema for partially updating a problem (used in PATCH request body)
# All fields are optional
class ProblemPartialUpdate(BaseModel):
    latex_text: Optional[str] = None
    category: Optional[CategoryLiteral] = None
    comments: Optional[str] = None
    latex_versions: Optional[List[str]] = None # Or Optional[Any]
    solution: Optional[str] = None

# Schema for representing a Problem in API responses (used in GET responses)
class ProblemSchema(ProblemBase):
    id: int # Include the ID generated by the database

    # Pydantic V2 configuration using ConfigDict
    model_config = ConfigDict(
        from_attributes = True # Replaces orm_mode=True
    )