# server/schemas/problemset.py
from pydantic import BaseModel, Field, ConfigDict
from typing import Optional, List
from enum import Enum

# Define the enum first
class ProblemsetStatusEnum(str, Enum):
    DRAFT = "DRAFT"
    FINALIZED = "FINALIZED"

# Import the schema for the link object
# Ensure this import path is correct relative to your project structure
from .problemset_problems import ProblemsetProblemsSchema

# Keep the AI Output schemas if still needed elsewhere
class ProblemOutput(BaseModel):
    latex_text: str
    category: str

class LectureProblemsOutput(BaseModel):
    lecture_name: str
    group_name: str
    problems_latex: List[ProblemOutput]

# --- NEW SCHEMAS FOR CRUD ---

# Base schema with fields common to Create, Update, and Read
class ProblemsetBase(BaseModel):
    title: str = Field(..., examples=["Algebra Basics"])
    type: str = Field(..., examples=["predavanje", "vjezbe", "ispit"]) # Lecture, exercises, exam
    part_of: str = Field(..., examples=["ljetni kamp", "skola matematike"]) # Context like camp or regular school
    group_name: Optional[str] = Field(None, examples=["pocetna", "napredna"]) # Target group, can be optional
    raw_latex: Optional[str] = Field(None, description="Raw LaTeX text of the problemset")
    status: ProblemsetStatusEnum = Field(default=ProblemsetStatusEnum.DRAFT)

# Schema for creating a new problemset (used in POST request body)
class ProblemsetCreate(ProblemsetBase):
    # No additional fields needed for creation beyond the base fields for now
    pass

# Schema for updating an existing problemset (used in PUT request body)
# Allows all fields from Base to be updated.
# For partial updates (PATCH), you might make fields Optional here.
class ProblemsetUpdate(ProblemsetBase):
    pass

# Schema for finalizing a problemset
class ProblemsetFinalize(BaseModel):
    raw_latex: str = Field(..., description="The complete LaTeX text to parse and save as problems")

# --- UPDATED SCHEMA FOR RESPONSES ---

# Schema for representing a Problemset in API responses (used in GET responses)
# Inherits from Base and adds database-generated fields and relationships
class ProblemsetSchema(ProblemsetBase):
    id: int # Include the ID generated by the database

    # Relationship using the Association Object Schema
    # This will include the position and the nested ProblemSchema
    problems: List[ProblemsetProblemsSchema] = []

    # Pydantic V2 configuration using ConfigDict
    model_config = ConfigDict(
        from_attributes = True # Replaces orm_mode=True in Pydantic v1
    )